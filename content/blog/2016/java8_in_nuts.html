---
title: "java8 in nuts"
created: !!timestamp '2016-01-18 22:40:00'
image: /media/images/blog/2016/java8_logov2.jpg
tags:
    - Java
---

{% block excerpt %}
{% mark excerpt %}
        [Java](https://www.oracle.com/java/index.html) is a old Object-oritented programming language.
        But recently,functional programming languages has risen in importance,
        because its very suitable for cocurrent and reactive programming ,so java8 has add functional programing to makes it
        mordern java
{% endmark %}
{% endblock %}

## Lambdas
    lambda is a block of code that pass around so it can be exectued later
    ### lambda examples
        {% syntax java %}
            //basic syntax (parameter) -> expression
            Comparator  comparator = (String s1, String s2) -> compare(s1.length(), s2.length());
                //if parameter types of lambda can be inferred, you can omit them
                comparator = (s1,s2) -> compare(s1.length(),s2.length());
                //if parameter is empty () -> {//block of code}
                Runnable r = () -> {for (int i=0;i<100;i++){
                System.out.println(i);
                }
                };

                Arrays.sort(new String[]{"ab","abc","a"},(s1,s2) -> compare(s1.length(),s2.length()));
                Thread t = new Thread( () -> {for (int i=0;i<100;i++){
                System.out.println(i);
                }
                }
                );
                t.start();
                t.join();
        {% endsyntax %}
        its illegal for a lambda expression to return a value in some branches but not in others
    ### functional interface
        the interface only have one single abstract method is called functional interface
        you can use lambda whenever a functional interface expected.
        in above example,comparator is a functional interface

    ### method references
        If there's already a method carries action that you'd like to pass to some other code
        you can use method reference.
        {% syntax java %}
             // these two sentence are same.
             Arrays.sort(new String[]{"a","b","c"},String::compareToIgnoreCase);
             Arrays.sort(new String[]{"a","b","c"},(String s1,String s2) -> s1.compareToIgnoreCase(s2));
         {% endsyntax %}
        three principle case
        1. object::instanceMethod
        2. Class::staticMethod
        3. Class::instanceMethod
        the first two cases is equivalent to the lambda expression that supplies the parameter of the method
        {% syntax java %}
            System.out::println == (x) -> System.out.println(x)
            Math::pow == (x,y)->Math.pow(x,y)
        {% endsyntax %}

        for the third case,the first parameter is the target of method, the method will be invoked on first parameter
        {% syntax java %}
            String::compareToIgnoreCase==(x,y)->x.compareToIgnoreCase(y)
        {% endsyntax %}


## Stream
    Java8 use streams to process collections of values , you just tell java what you want instead of how you want to get it
    you leave that to stream library to parallelize the operation using multiple threads for computing sums and counts etc.
    ###basic syntax
    {% syntax java %}
    @Test
    public void testStream(){
        List  words = Arrays.asList("A","B","cdefghijklmn","JKL","XY","Z");
        long count = words.stream().filter((s) -> s.length()>2).count(); //very easier to read , easy to parallelized(use parallelStream())
        System.out.println(count);
        }
    {% endsyntax %}
   ### difference with collections
        1. stream not store element
        2. stream didn't mutate the source
        3. stream operation are <em>lazy</em> ,not execute untile result is needed
        4. stream follow "what , not how" principle

   ### stream creation

        {% syntax java %}
            @Test
            public void testStreamCreation() throws IOException {
            Stream stream = Stream.of(1,3,2,6,3); // use values to create a stream
            Stream empty = Stream.empty(); //empty stream
            Stream infinite = Stream.generate(Math::random); //infinite stream
            Stream fileContent = Files.lines(Paths.get("1.txt")); // file content
            stream.forEach(System.out::println);
            fileContent.forEach(System.out::println);
            }
        {% endsyntax %}
   ### stream transformation
        ## filter
             words.stream().filter((s) -> s.length()>20) // transform original stream to stream only have long words
        ## map
             {% syntax java %}
                @Test
                public void testMap() throws IOException {
                    Stream  stream = Files.lines(Paths.get("1.txt")); //
                    stream.map(s -> s.length()).forEach(System.out::println); // after map, the new stream is the length of each line

                }
            {% endsyntax %}
        ##flatmap
            {% syntax java %}
                    class Developer {

                        private String name;
                        private Set  languages;

                        public Developer(String name) {
                            this.languages = new HashSet<>();
                            this.name = name;
                        }

                        public void add(String language) {
                            this.languages.add(language);
                        }

                        public Set  getLanguages() {
                            return languages;
                        }
                    }



                    @Test
                    public void testFlatMap() {
                    List team = new ArrayList<>();
                        Developer polyglot = new Developer("esoteric");
                        polyglot.add("clojure");
                        polyglot.add("scala");
                        polyglot.add("groovy");
                        polyglot.add("go");

                        Developer busy = new Developer("pragmatic");
                        busy.add("java");
                        busy.add("javascript");

                        team.add(polyglot);
                        team.add(busy);

                        List  teamLanguages = team.stream().
                            map(d -> d.getLanguages()).
                            flatMap(l -> l.stream()).
                            collect(Collectors.toList());
                            assertTrue(teamLanguages.containsAll(polyglot.getLanguages()));
                            assertTrue(teamLanguages.containsAll(busy.getLanguages()));

                            }
            {% endsyntax %}
 {# Local Variables: #}
 {# mode: markdown #}
 {# End: #}