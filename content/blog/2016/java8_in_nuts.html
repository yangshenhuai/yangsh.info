---
title: "java8 in nuts"
created: !!timestamp '2016-01-18 22:40:00'
image: /media/images/blog/2016/java8_logov2.jpg
tags:
    - Java
---

{% block excerpt %}
{% mark excerpt %}
[Java](https://www.oracle.com/java/index.html) is a old Object-oritented programming language.
But recently,functional programming languages has risen in importance,
because its very suitable for cocurrent and reactive programming ,so java8 has add functional programing to makes it mordern java
{% endmark %}
{% endblock %}

## Lambdas
lambda is a block of code that pass around so it can be exectued later
        {% syntax Java %}
            //basic syntax (parameter) -> expression
            Comparator  comparator = (String s1, String s2) -> compare(s1.length(), s2.length());
            //if parameter types of lambda can be inferred, you can omit them
            comparator = (s1,s2) -> compare(s1.length(),s2.length());
            //if parameter is empty () -> {//block of code}
            Runnable r = () -> {for (int i=0;i<100;i++){
                System.out.println(i);
                }
            };
            Arrays.sort(new String[]{"ab","abc","a"},(s1,s2) -> compare(s1.length(),s2.length()));
            Thread t = new Thread( () -> {for (int i=0;i<100;i++){
            System.out.println(i);
            }
            }
            );
            t.start();
            t.join();
        {% endsyntax %}
        its illegal for a lambda expression to return a value in some branches but not in others
        the interface only have one single abstract method is called functional interface
        you can use lambda whenever a functional interface expected.
        in above example,comparator is a functional interface
        If there's already a method carries action that you'd like to pass to some other code
        you can use <b>method reference</b>
        {% syntax Java %}
             // these two sentence are same.
             Arrays.sort(new String[]{"a","b","c"},String::compareToIgnoreCase);
             Arrays.sort(new String[]{"a","b","c"},(String s1,String s2) -> s1.compareToIgnoreCase(s2));
         {% endsyntax %}
        three method reference principle case
        - object::instanceMethod
        - Class::staticMethod
        - Class::instanceMethod
        the first two cases is equivalent to the lambda expression that supplies the parameter of the method
        {% syntax Java %}
            System.out::println == (x) -> System.out.println(x)
            Math::pow == (x,y)-> Math.pow(x,y)
        {% endsyntax %}

        for the third case,the first parameter is the target of method, the method will be invoked on first parameter
        {% syntax Java %}
            String::compareToIgnoreCase==(x,y)->x.compareToIgnoreCase(y)
        {% endsyntax %}
    Java8 use streams to process collections of values , you just tell Java what you want instead of how you want to get it
    you leave that to stream library to parallelize the operation using multiple threads for computing sums and counts etc.

    {% syntax Java %}
    @Test
    public void testStream(){
        List  words = Arrays.asList("A","B","cdefghijklmn","JKL","XY","Z");
        long count = words.stream().filter((s) -> s.length()>2).count(); //very easier to read , easy to parallelized(use parallelStream())
        System.out.println(count);
        }
    {% endsyntax %}

          stream not store element
          stream didn't mutate the source
          stream operation are lazy ,not execute untile result is needed
          stream follow "what , not how" principle


        {% syntax Java %}
            @Test
            public void testStreamCreation() throws IOException {
            Stream stream = Stream.of(1,3,2,6,3); // use values to create a stream
            Stream empty = Stream.empty(); //empty stream
            Stream infinite = Stream.generate(Math::random); //infinite stream
            Stream fileContent = Files.lines(Paths.get("1.txt")); // file content
            stream.forEach(System.out::println);
            fileContent.forEach(System.out::println);
            }
        {% endsyntax %}




       - filter
             words.stream().filter((s) -> s.length()>20) // transform original stream to stream only have long words
       - map
             {% syntax Java %}
                @Test
                public void testMap() throws IOException {
                    Stream  stream = Files.lines(Paths.get("1.txt")); //
                    stream.map(s -> s.length()).forEach(System.out::println); // after map, the new stream is the length of each line

                }
            {% endsyntax %}
        - flatmap
            {% syntax Java %}
                    class Developer {

                        private String name;
                        private Set  languages;

                        public Developer(String name) {
                            this.languages = new HashSet<>();
                            this.name = name;
                        }

                        public void add(String language) {
                            this.languages.add(language);
                        }

                        public Set  getLanguages() {
                            return languages;
                        }
                    }



                    \@Test
                    public void testFlatMap() {
                    List team = new ArrayList<>();
                        Developer polyglot = new Developer("esoteric");
                        polyglot.add("clojure");
                        polyglot.add("scala");
                        polyglot.add("groovy");
                        polyglot.add("go");

                        Developer busy = new Developer("pragmatic");
                        busy.add("Java");
                        busy.add("Javascript");

                        team.add(polyglot);
                        team.add(busy);

                        List  teamLanguages = team.stream().
                            map(d -> d.getLanguages()).
                            flatMap(l -> l.stream()).
                            collect(Collectors.toList());
                            assertTrue(teamLanguages.containsAll(polyglot.getLanguages()));
                            assertTrue(teamLanguages.containsAll(busy.getLanguages()));

                            }
            {% endsyntax %}
 {# Local Variables: #}
 {# mode: markdown #}
 {# End: #}