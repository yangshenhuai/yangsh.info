---
title: "java8 in a Nutshell--Stream API"
created: !!timestamp '2016-1-21 23:20:00'
image: /media/images/blog/2016/streams.png
tags:
- Java
---

{% block excerpt %}
{% mark excerpt %}
Stream are the key abstraction in Java8 for processing collections of value.
Streams follow the "what,not how" priciple,you don't need to specify how to get the data.
you just specify how the computation should work.
{% endmark %}
{% endblock %}

# Stream Creation
for collection,you can call <b>stream(or parallStream)</b> method to create a stream
{% syntax Java %}
List<String> words =...
long count = words.stream().filter((s) -> s.length()>2).count();
{% endsyntax %}
or create with <b>Stream.of</b> method
{% syntax Java %}
Stream<String> stream = Stream.of("A,B,C".split(","));
Stream<String> stream = Stream.of("A","B","C");
Stream<String> empty = Stream.empty(); // empty Stream
{% endsyntax %}
and you can also create a infinite stream using <b>generate</b> method
{% syntax Java %}
Stream.generate(Supplier<T> s);
//for example
Stream<Double> randoms = Stream.generate(Math::random)
{% endsyntax %}

#filter,map,flatMap
all these methods are transformation operations,these operations will read data from stream
and put transferred data into another stream(stream operation will not mutate the original data.)
{% syntax Java %}
/**
* Returns a stream consisting of the elements of this stream that match
* the given predicate.
*
* <p>This is an <a href="package-summary.html#StreamOps">intermediate
* operation</a>.
*
* @param predicate a <a href="package-summary.html#NonInterference">non-interfering</a>,
*                  <a href="package-summary.html#Statelessness">stateless</a>
*                  predicate to apply to each element to determine if it
*                  should be included
* @return the new stream
*/
Stream<T> filter(Predicate<? super T> predicate);


/**
* Returns a stream consisting of the results of applying the given
* function to the elements of this stream.
*
* <p>This is an <a href="package-summary.html#StreamOps">intermediate
* operation</a>.
*
* @param <R> The element type of the new stream
* @param mapper a <a href="package-summary.html#NonInterference">non-interfering</a>,
*               <a href="package-summary.html#Statelessness">stateless</a>
*               function to apply to each element
* @return the new stream
*/
<R> Stream<R> map(Function<? super T, ? extends R> mapper);


/**
* Returns a stream consisting of the results of replacing each element of
* this stream with the contents of a mapped stream produced by applying
* the provided mapping function to each element.  Each mapped stream is
* {@link java.util.stream.BaseStream#close() closed} after its contents
* have been placed into this stream.  (If a mapped stream is {@code null}
* an empty stream is used, instead.)
*
* <p>This is an <a href="package-summary.html#StreamOps">intermediate
* operation</a>.
*
* @apiNote
* The {@code flatMap()} operation has the effect of applying a one-to-many
* transformation to the elements of the stream, and then flattening the
* resulting elements into a new stream.
*
* <p><b>Examples.</b>
*
* <p>If {@code orders} is a stream of purchase orders, and each purchase
* order contains a collection of line items, then the following produces a
* stream containing all the line items in all the orders:
* <pre>{@code
*     orders.flatMap(order -> order.getLineItems().stream())...
* }</pre>
*
* <p>If {@code path} is the path to a file, then the following produces a
* stream of the {@code words} contained in that file:
* <pre>{@code
*     Stream<String> lines = Files.lines(path, StandardCharsets.UTF_8);
*     Stream<String> words = lines.flatMap(line -> Stream.of(line.split(" +")));
* }</pre>
* The {@code mapper} function passed to {@code flatMap} splits a line,
* using a simple regular expression, into an array of words, and then
* creates a stream of words from that array.
*
* @param <R> The element type of the new stream
* @param mapper a <a href="package-summary.html#NonInterference">non-interfering</a>,
*               <a href="package-summary.html#Statelessness">stateless</a>
*               function to apply to each element which produces a stream
*               of new values
* @return the new stream
*/
<R> Stream<R> flatMap(Function<? super T, ? extends Stream<? extends R>> mapper);


{% endsyntax %}


{# Local Variables: #}
{# mode: markdown #}
{# End: #}