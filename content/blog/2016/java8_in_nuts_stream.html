---
title: "java8 in a Nutshell--Stream API"
created: !!timestamp '2016-1-21 23:20:00'
image: /media/images/blog/2016/streams.png
tags:
- Java
---

{% block excerpt %}
{% mark excerpt %}
Stream are the key abstraction in Java8 for processing collections of value.
Streams follow the "what,not how" priciple,you don't need to specify how to get the data.
you just specify how the computation should work.
{% endmark %}
{% endblock %}

# Stream Creation
for collection,you can call <b>stream(or parallStream)</b> method to create a stream
{% syntax Java %}
List<String> words =...
long count = words.stream().filter((s) -> s.length()>2).count();
{% endsyntax %}
or create with <b>Stream.of</b> method
{% syntax Java %}
Stream<String> stream = Stream.of("A,B,C".split(","));
Stream<String> stream = Stream.of("A","B","C");
Stream<String> empty = Stream.empty(); // empty Stream
{% endsyntax %}
and you can also create a infinite stream using <b>generate</b> method
{% syntax Java %}
Stream.generate(Supplier<T> s);
//for example
Stream<Double> randoms = Stream.generate(Math::random)
{% endsyntax %}

#filter,map,flatMap
all these methods are transformation operations,these operations will read data from stream
and put transferred data into another stream(stream operation will not mutate the original data.)
{% syntax Java %}
/\*\*
\* Returns a stream consisting of the elements of this stream that match
\* the given predicate.
\*
\* <p>This is an <a href="package-summary.html#StreamOps">intermediate
\* operation</a>.
\*
\* @param predicate a <a href="package-summary.html#NonInterference">non-interfering</a>,
\*                  <a href="package-summary.html#Statelessness">stateless</a>
\*                  predicate to apply to each element to determine if it
\*                  should be included
\* @return the new stream
\*/
Stream<T> filter(Predicate<? super T> predicate);


/\*\*
\* Returns a stream consisting of the results of applying the given
\* function to the elements of this stream.
\*
\* <p>This is an <a href="package-summary.html#StreamOps">intermediate
\* operation</a>.
\*
\* @param <R> The element type of the new stream
\* @param mapper a <a href="package-summary.html#NonInterference">non-interfering</a>,
\*               <a href="package-summary.html#Statelessness">stateless</a>
\*               function to apply to each element
\* @return the new stream
\*/
<R> Stream<R> map(Function<? super T, ? extends R> mapper);


/\*\*
\* Returns a stream consisting of the results of replacing each element of
\* this stream with the contents of a mapped stream produced by applying
\* the provided mapping function to each element.  Each mapped stream is
\* {@link java.util.stream.BaseStream#close() closed} after its contents
\* have been placed into this stream.  (If a mapped stream is {@code null}
\* an empty stream is used, instead.)
\*
\* <p>This is an <a href="package-summary.html#StreamOps">intermediate
\* operation</a>.
\*
\* @apiNote
\* The {@code flatMap()} operation has the effect of applying a one-to-many
\* transformation to the elements of the stream, and then flattening the
\* resulting elements into a new stream.
\*
\* <p><b>Examples.</b>
\*
\* <p>If {@code orders} is a stream of purchase orders, and each purchase
\* order contains a collection of line items, then the following produces a
\* stream containing all the line items in all the orders:
\* <pre>{@code
\*     orders.flatMap(order -> order.getLineItems().stream())...
\* }</pre>
\*
\* <p>If {@code path} is the path to a file, then the following produces a
\* stream of the {@code words} contained in that file:
\* <pre>{@code
\*     Stream<String> lines = Files.lines(path, StandardCharsets.UTF_8);
\*     Stream<String> words = lines.flatMap(line -> Stream.of(line.split(" +")));
\* }</pre>
\* The {@code mapper} function passed to {@code flatMap} splits a line,
\* using a simple regular expression, into an array of words, and then
\* creates a stream of words from that array.
\*
\* @param <R> The element type of the new stream
\* @param mapper a <a href="package-summary.html#NonInterference">non-interfering</a>,
\*               <a href="package-summary.html#Statelessness">stateless</a>
\*               function to apply to each element which produces a stream
\*               of new values
\* @return the new stream
\*/
<R> Stream<R> flatMap(Function<? super T, ? extends Stream<? extends R>> mapper);
{% endsyntax %}

lets see some examples about these methods ,suppose we have Developer as VO.
a Developer have name,and can use several languages.
{% syntax Java %}
class Developer {

private String name;
private Set<String> languages;

public Developer(String name) {
this.languages = new HashSet<>();
this.name = name;
}
public String getName(){
return this.name;
}
public void add(String language) {
this.languages.add(language);
}

public Set<String> getLanguages() {
return languages;
}
}

{% endsyntax %}

and suppose now we have a list of Developers
{% syntax Java %}
List<Developer> developers = DeveloperService.getAllDevelopers();
{% endsyntax %}

and you want print every developer name whose name start with "Peter"
{% syntax Java %}
developers.stream().map((d)-> d.getName() ).filter((name) -> name.startWith("Peter")).forEach(System.out::println) ;
// the map method will generate a new stream which consist of developer names
// and then invoke filter on that stream , and check if name start with "Peter" , if exists, it will put another new Stream
//Finally print every name in the new Stream
{% endsyntax %}
Now suppose you want all set languages of all the developers
{% syntax Java %}
developers.stream.map((d)->d.getLanguages()).forEach(System.out::println)
{% endsyntax%}
But this will end up print some list like below output
{% syntax Java %}
[groovy, scala, clojure, go]
[java, javascript]
{% endsyntax %}
but what if I just want one total list of languages, for this requirement,you can use flatMap
{% syntax Java %}
developers.stream().
map(d -> d.getLanguages())
.flatMap(l -> l.stream())
.forEach(System.out::println);
{% endsyntax %}
now you can get result like below
{% syntax Java %}
groovy
scala
clojure
go
java
javascript
{% endsyntax %}
Perfect!


                {# Local Variables: #}
{# mode: markdown #}
{# End: #}